# gulishop-client
#项目说明书
购物车
登陆
注册
## 第一天
      1.脚手架构建项目框架，删除不必要内容，修改相关配置
      2.主要掌握main.js基本编码
      3.git基本操作 -git init 初始化一个本地库
                   -git remote add origin http://
                   -git add .
                   -git commit -m'first' 放到提交区
                   -git push origin master 放到git主分支上
                   -git pull origin master 从远程拉过来
      4.观察页面主体框架，引入header footer 非路由组件
      5.配置路由，路由meta配置，路由传参
## 第二天
      1.TypeNav公用模块，在main.js中全局注册
      2.Home主页模块注册，完成静态页面
      3.axios二次封装（axios.js） -安装
                     - 引入
                     - 二次封装以加入额外功能 ，因此要创建新的实例，同时完成基础路径配置
                     - 在请求拦截器中加入额外功能
                     - 把封装好的axios实例导出
      4.封装接口请求函数（index.js），
                                    并测试验证接口是否可以请求成功（导入到main.js中测试）
                                    需在webpack配置文件中配置代理，否则本地请求接口路径
                                    与supermall不同的是，该项目公共接口路径没有写服务器地址，而是在webpack配置中进行代理
      5.vuex的配置，modules的配置
      6.home模块vuex三连环配置，并在vue中触发，数据储存到vuex中
      7.从vuex中把数据捞到vue中进行展示(TypeNav 三级分类)，仔细看拿到的数据去使用v-for
## 第三天
      1.事件控制23级的显示和隐藏
            原来是用css做的，现在改为一个类，在item身上动态的强制绑定class，{item_on：布尔值}，布尔值为true，当前类则生效
            鼠标移入哪个item，就让当前item类为true：设计一个data，currentIndex = -1，移入的时候让currentIndex = index
      2.用div包裹item和h2，给div加上鼠标移出事件
      3.防抖节流 => 是什么， 在哪用
            100ms触发100次，正常：事件触发非常频繁，每次触发都会执行回调函数，回调函数有内部计算会发生卡顿
                           节流：在规定的间隔范围内不会重复触发回调，只有大于这个时间间隔才会触发回调，把频繁触发变为少量触发
                           防抖：前面的所有的触发都被取消，最后一次执行在规定时间之后才会，也就是说如果连续快速触发，只会执行一次
            节流：引入lodash进行节流。
            { 'trailing': true, leading: false } trailing：是否在时间间隔之后执行函数 leading：是否在时间间隔之前执行函数
      4.使用声明式导航实现点击类别跳转搜索页面，通过query参数传递
      5.使用编程式导航优化声明式导航组件导致的对象过多造成的卡顿
      6.利用事件委派提高处理事件的效率：
            每个分类项都添加事件，事件的回调函数很多，效率很低
            在共同的祖先元素添加事件监听(tosearch)
            给a标签绑定data-自定义属性
            编写事件委派回调函数
      7.搜索页typeNav一级列表隐藏（v-show）
            在组件mounted的时候进行判断
            移出的时候添加移出事件，改为回调函数实现
      8.实现typeNav一级列表过渡效果
            transition标签，v-enter
      9.优化typeNav数据ajax请求次数，改变请求位置
            之前在typeNav组件内部dispatch发送ajax请求
            typeNav被多个页面公用，因此每次切换都会重新发送请求
            所有改放到app中执行
      10.合并分类的query参数和搜索关键字的params参数
            找到对应组件
            点击search按钮（params参数）的时候，看看有没有query参数
            点击分类类别（query参数）的时候，看看有没有params参数
## 第四天
      1.模拟接口（其实和ajax差不多，mock其实就是给我们的json数据指定一个url路径去做请求）
            设计json数据的结构和值 => banner.json floor.json
            安装mockjs
            使用mockServer.js来模拟提供接口地址
            再main中引入mockServer.js
            在ajax中修改Ajax中的baseUrl 为/MOCK 变为一个新的文件 mockAjax
      2.动态显示ListContainer组件和floor组件
            写api里面的接口请求函数，请求获取模拟接口的数据banner和floor
            写vuex中的三连环
            在组件中dispatch 发请求获取数据存储到vuex
            在组件中computed内部，从拍你给vuex当中把数据捞到组件
            在组件中展示我们的动态数据
      3.轮播图实现
            swiper用法参考官方网站
            1.安装
            2.引入js和css  => 可以查看页面结构是否正常 ，正常就代表css没问题
            3.书写swiper结构
            4.实例化swiper实例对象
            注意：swiper必须在页面的数据结构显示完成后创建才会生效
      4.使用watch + nextTick 解决轮播图加载问题
      5.定义可复用轮播组件
## 第五天
      1.实现search与searchSelector静态组件
      2.search接口测试和编写请求函数 api => index
      3.search模块vuex编码 store

      5.search组件动态显示
            data设置初始准备参数已经设置好了
            在mounted内部可以发送请求
            在computed内部获取数据
            search页面商品动态数据展示
            searchSelector组件内部动态展示
      4.搜索条件参数的理解和初始data收集参数准备
      6.根据分类和关键字进行搜索,解决在search组件内部再搜索一次的bug
            data当中需要定义一个对象,代表是所有的搜索条件组成的对象,称为初始化搜索参数
                  一部分是空串，以后搜索的时候自己给
                  一部分是给定的，默认传递给后台的搜索参数
            真正到了搜索页面 需要去解析拿到相关的参数 修改搜索参数
            beforeMount 同步更新data数据
            mounted 异步发送请求
            搜索页面重新输入关键字或者点击类别不会再发送请求,因为mounted只会执行一次,需要监视路由变化      
      7.动态显示和删除选中的搜索条件发送请求
            判断参数内部是否存在categoryName 存在就显示
            判断参数内部是否存在keyword 存在就显示
            点击事件，如果删除就把参数对应的数据清楚，顺便发送新的请求
      8.解决删除选中的搜索条件后，路径不变的bug
            上面删除发送请求外卖的请求路径还是不变
            需要手动去push跳转到去除对应参数的路由
      9.解决删除关键字后，输入框没有更新的bug
            组件间通信，删除关键字后通知header组件，全局事件总线的使用
      10.根据品牌搜索（设置和删除）
            给对应品牌添加点击事件
            点击的时候需要给父组件search传递品牌的参数 ，参数结构参考接口文档
            子向父通信 => 自定义事件
      11.属性搜索，解决点击属性多次根据同一属性搜索的bug（some方法）
## 第六天
     1.解决在搜索页多次跳转后不能直接返回home的问题
            查看之前书写的所有跳转路由
            如果是搜索页往搜索页去跳转，使用replace
            如果是home页往搜索页跳转，使用push （head和typenav处需要判断）
      2.解决发送搜索请求的参数中有空串的问题
            浏览器发送ajax请求，携带属性如果是undefined，这个参数属性是不会发送的，不占带宽
            但如果是‘’ 则会发送，占带宽
            因此，在封装的发送请求函数中处理
      3.排序数据的分析4种情况
            order：'1：desc' 排序是根据这个数据排的
            冒号前面表示排序标志 1表示综合排序 2表示价格排序 接口文档给出
            冒号后面表示排序类型 asc表示升序，desc表示降序
            因此一共有四种情况
      4.动态确定排序项的排序方式
            1.背景色跟谁（在综合上还是价格上） 根据数据中排序标志决定
            2.让图标可以动态显示
              用啥图标
              图标什么时候出现    和背景色一样，谁有背景色，那么谁就有图标
              图标是向上还是向下  和数据排序类型相关asc和desc
              引入iconf
            3.点击排序项切换排序
              需要判断点击的是不是原来那个排序
            4.模板内部的表达式优化计算属性
                  可以通过computed去优化代码，因为原来代码比较长
      5.分页组件
            引入静态页面
            全局注册并渲染
            实现动态组件
                  分页器用处：1.用于展示当前页码，2.用于展示总条数，3.用于展示总页码，4.用于展示连续页数，5.翻页
                  分页器需要什么数据：1.当前页码、总页码和总条数、连续页数，分页器本身没有，但父组件中有 =>  组件通信
## 第七天
      1. 详情页
            静态页面，路由注册配置
            携带params参数，路由跳转滚动
      2. 详情页动态展示
            ajax请求函数
            vuex管理
            获取数据
            展示数据
      3.展示图片列表以及放大镜的图片
            解决报假错问题
      4.点击销售属性，切换选中状态 => 排他
      5.点击小图，切换每个小图的橙色边框，同时上面的zoom大图也做切换
      6.小图列表的轮播实现
      7.放大镜的实现
      8.商品购物数量的输入交互
      9.添加购物车（！重点）
## 第八天
      1.实现添加购物车页面动态展示，点击查看商品详情返回详情页
      2.购物车结算静态页面，路由配置
      3.写api，三连环，请求获取到的是一个空数组
      4.生成用户临时标识（uuid），请求获取购物车结算页面
      5.购物车结算页面动态展示（展示需要计算的数据，用到every，v-model处理check）
      6.购物车结算页面的修改商品数量问题 => 先发请求后修改 （！重点）
      7.修改购物车结算页面选中状态 => promise all
## 第九天
      1.实现删除购物车商品
      2.登陆注册静态页面
      3.用户注册逻辑，验证码自动填写实现
      4.用户登陆逻辑 => 静态组件，api，store，收集数据发送请求
            user的state中存储的是token，初始化为空串，自动登陆时才存储token的问题
            user的mutation中直接修改用户的token
            user的action中发请求，成功提交mutation修改用户的token
            登陆成功的标志就是用户可以拿到token
      5.根据登陆token获取用户信息（token校验，也可以去判定token是不是过期）=> 路由导航守卫
            路由导航守卫的理解
                  当路由跳转的时候，守卫可以拦住，检测是否有去往这个页面的条件
                  有特定条件才能到相应页面的功能
                  拦截路由，查看是否满足条件，满足的放行，不满足的处理
            全局导航守卫：
                  无论是从哪个页面往哪个页面跳转，只要有路由跳转，就会拦住，进行检测
                  前置守卫： 配置的比较靠前 => 匹配路由前拦截
                  解析守卫： 配置的位置中间 => 匹配路由中拦截
                  后置守卫： 配置的比较靠后 => 匹配路由完成拦截，用的少
            路由独享守卫：
                  只能去拦住固定的往某个页面跳转的，是配置再当前路由当中，时间比较靠前
                  前置守卫： 配置的比较靠前 => 匹配路由前拦截
                  解析守卫： 配置的位置中间 => 匹配路由中拦截
                  后置守卫： 配置的比较靠后 => 匹配路由完成拦截，用的少
            组件内守卫：
                  只能去拦住固定的往某个页面跳转的，是配置在组件内部，也就是路由匹配已经完成了，时间比较靠后
                  只有一个，就是解析完了，已经跳转到组件的时候，但是组件还没创建成功的时候拦截
      6.把登陆的token添加到请求头，书写根据token获取用户信息的请求
      7.设置全局守卫当中的token校验
      8.实现用户自动登录 => 保存token信息到localStorage中，且初始化的时候要先从localStorage中去拿
            当token过期，要从localStorage中清空token信息
      9.实现用户的退出登录
            请求成功在store中把用户信息和token的数据清楚 => state和localStorage都要清除
            userTempId 和 token的区别
                  userTempId 未登录状态下的用户身份识别标识
                  token 登陆状态下的用户身份识别标识
                  两个都存在，后台会合并临时id对应的信息到token对应的信息上，token是老大
## 第十天
      1.订单交易页面的静态实现
      2.api和store获取地址信息和交易信息
      3.动态交互默认地址改变
      4.实现订单交易页面的提交订单
            先发送请求，提交订单交易信息，正儿八经的创建订单
            成功返回订单编号 然后把订单编号携带跳转路由去到订单支付页面
            支付页面还需要发送一个请求获取支付信息，支付信息里包括了订单金额
      5.订单支付页面会出现支付二维码
            element-ui的引入
                  安装，安装按需引入的babel相关的包
                  配置babel文件，引入并注册使用 => 点击立即支付弹出消息盒子
      6.支付流程
            生成二维码
            展示完二维码立即开始轮询！ => 每隔2秒发一次请求，查询支付状态
            根据返回的支付状态码去决定后续操作
                  如果查询回来是200 ，自动跳转成功页面，关闭消息盒子
                  同时保存状态码到data中，用来作为用户点击已成功支付按钮的判断依据
            单独处理点击支付成功或问题按钮的逻辑
                  点击成功则判断是否成功
                  点击遇到问题则发出提示并停止发送请求，关闭消息盒子
      7.支持成功后跳转支付成功页面
            再次页面可以选择继续购物，去到首页，也可以查看订单，去到用户中心
      8.我的订单页面静态页面，及二级路由组件的拆分和使用
## 第十一天
      1.获取并我的订单页面动态数据，不用vuex，直接存到data中
      2.我的订单页面单元格合并
      3.我的订单页面分页器处理
      4.使用全局路由导航守卫解决未登录问题
            如果没登陆，访问相关页面将会跳转登陆页面
            登陆后会自动跳转前面想去的页面
