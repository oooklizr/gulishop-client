## 一、项目步骤

单页面应用

购物车，支付，订单

主体结构：由于头尾不动，中间在变  =>  中间部分是路由组件，页面不刷新，切换过程采用ajax请求

六个组件：**Header**和**Footer**是固定的所以是非路由组件，

​					**Home,Search,Login,Register**都是点击跳转所以是一级路由组件（内部可能会有二级）

是什么？为什么？怎么做？

####  1.第一天

##### 1.**Header和Footer非路由组件的使用： **

​	在components文件夹中**定义**，在App.vue中**注册**和**引用**  =>  引入html，less及图片到vue组件，解决loader

##### 2.理解路由组件和非路由组件的区别

​	使用都是三大步 ： 定义 注册 使用

​	**定义**都是一样的， 只是定义的文件夹不同，Header页面在Header中，Search页面在Search中

​	**注册**时候的区别：非路由组件是注册在**要使用的组件**当中，而路由组件是要在路由配置中注册的

​	**使用**时候的区别：非路由组件使用注册的组件标签

​	路由组件使用声明式导航（router-link  =>  替换a标签, router-view  =>  替换组件标签） 和编程式导航来使用（push replace router-view）

​	非路由组件和路由组件生命周期不同： 路由组件在切换的时候，会销毁重建（keep-alive可以保持不销毁）而非路由组件不会

##### 3.路由组件的使用三大步

​	定义：在相关文件夹中定义路由页面

​	注册：将路由插件引入router文件中，向外暴露一个路由器对象（配置路由），在main中挂载

​	使用：在需要的地方使用，Search按钮使用push编程式导航

##### 4.解决Footer组件的隐藏问题

​	在登陆和注册页面的配置路由中，配置meta对象：`isHidden = true`，给Footer组件添加`v-show=‘$route.meta.isHidden‘`去判断

##### 5.路由传参配置

###### 	5.1路由跳转原理：

​		1.组件中点击声明式导航或编程式导航（内部可加自己的逻辑，更加灵活），改变路径

​		2.当用户改变路径，这个路径会到路由器当中的路由数组内部和路由对象的路径一个一个匹配，直到找到相应路径

​		3.其中，传递的params参数，会被路由对象的路径后面的xxx（任意名字占位）匹配且收集，最终会被自动放到当前这个路由对象的params属性中

​		4.query参数不会在匹配的时候占位，但是也会在匹配时收集到当前路由对象的query属性中

​		5.页面切换到刚匹配成功的路由组件，显示组件的同时会把刚才匹配到的路由对象也放到该组件的$route中

###### 	5.2**路由传参种类**：

​							   params参数和query参数

   			params参数是属于路径的一部分，路由当中匹配的时候，path路径是要照顾到这个参数的
   	
   			query 参数是在路径后面，以？分割 ，？后面的 a = b & c = d就是你的query参数
   	
   			query参数是不属于路径的一部分，路由匹配的时候，path路径不需要关心我这个参数

###### 	5.3路由路径带参数的三种写法（使用阶段）：

   1、字符串写法

```
this.$router.push('/search/'+this.keyword + '?keyword1=' + this.keyword.toUpperCase())
```

   2、模板字符串

```
this.$router.push(`/search/${this.keyword}?keyword1=${this.keyword.toUpperCase()}`)
```

   3、对象写法（重点）

```
   this.$router.push({

   name: "search",

   params: { keyword: this.keyword },

   query: { keyword1: this.keyword.toUpperCase() },

   });
```

###### 	5.4关于路由的面试问题

#### 2.第二天

##### 1.拆分home页组件，实现home静态页面

​		其中typeNav由home和search页公用，因此**定义**到components文件夹中，在main中**全局注册**，在home和search页**使用**

​		其他组件直接在home中注册使用

##### 2.axios二次封装

​		   -安装，引入

​           \- 在ajax.js中二次封装以加入额外的进度条功能 ，因此要创建新的实例，同时完成基础路径配置

​           \- 在请求拦截器中加入额外功能  => 添加进度条信息 nprogress

​           \- 把封装好的axios实例导出，导入到下面文件中

​			在api文件夹中的index.js中封装接口请求函数（返回的是promise），以后想要拿什么数据，就调用该文件中的对应请求函数

##### 3.vuex的配置

​	vuex的定义，注册，使用。和路由组件的使用方法一样。

​	vuex四大核心概念：

​		state存数据，

​		mutations直接修改数据，存到state中

​		actions在组件中与用户对接，用await和async发送异步请求从接口拿数据，提交给mutations，存到state中

​					await和async的作用：可以通过同步代码实现异步效果，可读性强

​					但此时请求还未发送，需要在组件中dispatch时，才会发送请求

​					因为组件在挂在完成的时候，就立马发请求拿数据，存到vuex中

​					所以在组件内部mounted()处发请求 => `this.$store.dispatch('getCategoryList')`  **！此处会遇到问题** ，第三天解决

​					dispatch就是分发和触发的意思，和emit一样，本质就是在调用指定的actions函数

​		getters简化数据

​		第五大概念：modules，代表模块化，模块化单独的home，search等vuex，最后再合并到总的vuex中

##### 4.从vuex拿数据到页面展示

​		只要是从vuex拿数据（即state和getters中的东西），都在组件的computed中拿，`...mapState()`

​		只要是从vuex拿方法（即mutations和actions中的东西），都在组件的methods中拿，一般很少用到

​		拿到数据之后，通过v-for 在html中展示

#### 3.第三天

##### 1.TypeNav二三级的显示和隐藏事件

​		原来是用css做的，现在改为一个类，在item身上动态的强制绑定class，{item_on：布尔值}，布尔值为true，当前类则生效

​		鼠标移入哪个item，就让当前item类为true：设计一个data，currentIndex = -1，移入的时候让currentIndex = index

##### 2.TypeNav组件防抖节流问题

​		鼠标移入分类列表过快导致浏览器卡顿  =>  防抖节流

​		对于100ms触发100次事件：

​			  正常：事件触发非常频繁，每次触发都会执行回调函数，回调函数有内部计算会发生卡顿

​              节流：在规定间隔范围内不会重复触发回调，只有大于这个时间间隔才会触发回调，把频繁触发变为少量触发（多次变成少量）

​              防抖：前面所有的触发都被取消，最后一次执行在规定时间之后，也就是说如果连续快速触发，只会执行一次（多次变成单次）

​		解决方案：节流  => TypeNav中引入lodash（已经在安装依赖的时候装好）进行节流：`{ 'trailing': true, leading: false }` 

​      						trailing：是否在时间间隔之后执行函数 leading：是否在时间间隔之前执行函数

​		节流后，传递的函数不能用箭头函数，因为箭头函数内部this不是组件对象

##### 3.点击分类列表跳转search页面

​		此项目中定义 => 点击分类列表传递query参数，点击搜索按钮传递params参数

​		第一种写法：a标签改为router-link，使用路由路径带参数的对象写法实现  =>  鼠标滑过出现卡顿

​		使用组件，本质是通过和标签名绑定好的构造函数，实例化一个对象，称作组件对象，因此每个router-link组件标签都是内存中对象

​		第二种写法：声明式导航改为编程式导航，click事件点击后要调用函数，同样会在内存中定义很多个函数，效率虽好但占有仍然较大

​		改进方法：**事件委派**

​							事件监听添加给共有的祖先元素，儿子身上事件发生会自动冒泡到爹身上，爹再回头去找发生事件的儿子进行处理

​							找公共的离自己最近的祖先元素，这个祖先元素只有一个（不能有v-for）

​		给祖先元素添加点击事件回调函数

​		问题：怎么知道点击的是不是a标签？怎么知道点击的a标签是一级分类还是二级三级分类？参数怎么携带？

​		点击事件的回调函数，通常会自动接收到一个实参（event）P113详细讲解event来源

​		事件委派的回调函数：

```javascript
 **toSearch**(event) {
   //event是事件对象，代表你传递的$event，只能在模板里出现
   // 每次触发事件，浏览器都会把这次触发事件相关的所有信息封装为一个对象
   //在浏览调用回调函数的时候，自动传递给回调函数的第一个形参
   let targetNode = event.target //获取我们的目标元素（真正发生事件的元素）
   // console.log(targetNode);
   let data = targetNode.dataset //给a标签绑定data-自定义属性（htmld），获取当前目标元素身上data-属性组成的对象
   // console.log(data);
   //怎么知道点击的是不是a标签？ 如果是a，那么data一定有categoryname，如果不是则没有
   //参数怎么携带？如果点的是a，那么参数已经带过来了，就在data中
   let {category1id,category2id,category3id,categoryname} = data
   if (categoryname) {
​    //categoryname存在证明点击的就是a
​    let location = {
​     name: 'search'
​    }
​    let query = {
​     categoryName: categoryname
​    }
​    //确定是一级还是二级还是三级id
​    if (category1id) {
​     query.category1Id = category1id
​    }else if(category2id) {
​     query.category2Id = category2id
​    }else {
​     query.category3Id = category3id
​    }
​    //找到所有的query参数之后，最后把query放到location里面
​    location.query = query
​    //合并参数
​    //跳转之前，要合并原来过来时候带的params参数，看看来之前有没有，有的话一起带上
​    if (this.$route.params) {
​     location.params = this.$route.params
​    }
​    //最终把location对象就构造好了，跳转
​    //如果是从home跳search，就push
​    //如果是search跳search，就replace
​    //如果当前路径不是在home中，就replace，否则push
​    if(this.$route.path !== '/home') {
​     this.$router.**replace**(location)
​    }else {
​     this.$router.**push**(location)
​    }
   }
 }
```

##### 4.实现search页分类列表隐藏

​		**v-show**实现，TypeNav组件mounted处判断是不是在search页面

##### 5.实现typeNav一级列表过渡效果

​		transition标签，**v-enter**

##### 6.优化typeNav数据ajax请求次数，改变请求位置

​		之前在typeNav组件内部dispatch发送ajax请求

​        typeNav被多个页面公用，而且分类列表数据是固定不变的，因此每次切换都会重新发送请求

​        所有改放到app中mounted时执行

##### 7.合并分类的query参数和搜索关键字的params参数

​		如上述代码

#### 4.第四天

##### 1.利用mockjs模拟ListContainer和floor的数据

​		其实和ajax差不多，mock其实就是给我们的json数据指定一个url路径去做请求

​		设计json数据的结构和值 => banner.json和floor.json

​		安装mockjs，在mockServer.js文件中来模拟提供接口地址

​		在main中引入mockServer.js

​		在ajax中修改Ajax中的baseUrl为/MOCK  =>  变为一个新的文件 mockAjax

##### 2.动态显示ListContainer组件和floor组件

​		在api里面写接口请求函数，请求获取模拟接口的数据banner和floor

​		写vuex中的三连环 

​		在组件中dispatch 发请求获取数据存储到vuex

​		在组件中computed内部，从拍你给vuex当中把数据捞到组件

​		在home组件中请求展示的数据，遍历给组件，再通过组件通信传到组件内部

##### 3.轮播图实现

​		使用**swiper**，用法参考官方网站 1.安装，2.引入js和css，3.书写swiper结构，4.实例化swiper实例对象

​		**注意**：swiper必须在页面的数据结构显示完成后创建才会生效

##### 4.解决此问题		

​		挂载完成后（mounted）去实例化swiper => 不行，因为实例化的时候，页面显示未必成功

​		按理说挂载完成页面的dom结构就算形成，在此去实例化应该是可以的

​		但是，页面中结构中的swiper-slide，是根据请求回来的数据动态创建生成的

​		所以必须保证请求数据回来后，再去实例化，有了数据，slide的div才会动态创建成功

​		dispatch发送请求是异步代码，而创建实例是同步代码首先执行，所以 该方法不行

​		定时器可以解决，但是不完美

​		用watch监视bannerList，一旦数据请求到（有变化）就去实例化swiper，但是还是不成功，因为请求到数据之后才开始v-for形成

​		用**nextTick**这个API实现 => 在最近的一次页面更新完成之后，执行nextTick中的回调函数

​		floor中的轮播图不存在此问题，在mounted中实例化就可以

​		但为了公用，用同一方法封装

#### 5.第五天

##### 1.实现search与searchSelector组件初始化数据展示

​		引入静态页面

​		写search页面请求接口函数  =>  post ，请求体参数，且dispatch传参

![image-20210813202612424](C:\Users\Razer\AppData\Roaming\Typora\typora-user-images\image-20210813202612424.png)

​		编写vuex的search模块，这次dispatch不在mounted中，而是另外封装成一个函数，目的是后期再发请求的时候可以调用

​		因为获取的数据内部结构比较复杂，使用起来不方便，甚至会出现小问题（假报错），因此可以用到vuex的   **getters**

​		在search页动态展示获取到的数据

##### 2.搜索条件参数的理解和初始data收集参数准备

​		初始化data：定义一个对象，代表所有搜索条件组成的对象，一部分是跟搜索条件有关的数据全部初始化为空串，即不带参数也可请求到search全部内容动态页面，以后搜索的时候要自己给内容，一部分是给定的，默认给后台传递的搜索参数，例如一页多少商品等，可以手动改（6.2解决此处问题）

​		在点击三级分类或者点击搜索按钮跳过来发请求之前，把对应的三级分类名称和id或者关键字keyword，拿到添加到data当中searchParams对应的搜索项当中  => **beforeMount**

##### 3.搜索页面重新输入关键字或者点击类别不会再发送请求的bug

​		因为**beforeMount**只会执行一次，因此需要**另外**在**watch监视**路由变化，再发请求

##### 4.动态显示面包屑，以及删除面包屑后重新发送请求

​		判断参数内部是否存在categoryName 存在就显示（**v-if**）（分类列表点击）

​		判断参数内部是否存在keyword 存在就显示（搜索框输入）

​		点击事件，如果执行回调函数（删除）就把参数对应的数据清除，顺便发送新的请求

##### 5.解决删除关键字后，输入框没有更新的bug

​		组件间通信，删除关键字后通知header组件，输入框中的关键字消失  =>  **全局事件总线**的使用

​		main中安装总线 => 代表任意组件内部都可以通过this.$bus访问到vm实例（总线）

​		search发生事件`this.$bus.$emit`，header接收`this.$bus.$on`

##### 6.解决删除选中的搜索条件后，路径不变的bug

​		需要手动去push跳转到去除对应参数的路由，然后watch监视到参数变化，就会重新发送请求

##### 7.根据品牌搜索（设置和删除）

​		给对应品牌添加点击事件，点击的时候需要给父组件search传递品牌的参数，父组件会发请求 ，参数结构参考接口文档

​		**子向父通信 => 自定义事件**

​		父组件中定义删除事件

##### 7.属性的动态展示和根据属性搜索（设置和删除）

##### 8.解决点击属性多次根据同一属性搜索的bug

​		判断数组中是否存在当前属性，如果有就不再发请求

​		**some方法**  => 只要数组中有一个和条件一样，返回true，如果都没有就false。参数：回调函数。返回布尔值

#### 6.第六天

##### 1.解决在搜索页多次跳转后不能直接返回home的问题

​		push和replace的区别：push有记录，一层一层往回返，replace没有记录，直接一次性返回

​		查看之前书写的所有跳转路由，如果是搜索页往搜索页去跳转，使用replace

​		如果是home页往搜索页跳转，使用push （head和typeNav处需要判断）

##### 2.解决发送搜索请求的参数中有空串的问题

​		浏览器发送ajax请求，携带属性如果是undefined，这个参数属性是不会发送的，不占带宽

​		但如果是‘’ 则会发送，占带宽

​		因此，用forEach遍历对象，在发送请求前把含空串的属性全部删掉

##### 3.实现商品排序功能

​		order：'1：desc' 排序是根据这个数据排的

​		冒号前：排序标志 1表示综合排序 2表示价格排序 接口文档给出

​		背景色和图标（在综合上还是价格上） 根据数据中排序标志决定，谁有背景色，那么谁就有图标，引入iconf

​		冒号后：排序类型 asc表示升序，desc表示降序

​		判断点击的是不是原来那个排序，从而切换排序

##### 4.分页器组件

​		定义，全局注册分页器组件，search组件中使用

​		分页器用处：1.用于展示当前页码，2.用于展示总条数，3.用于展示总页码，4.用于展示连续页数，5.翻页

​		分页器需要什么数据：当前页码、总页码和总条数、连续页数，分页器本身没有，但父组件中有 => 组件通信

​		**计算连续页的起始位置和结束位置**

​		搜索条件改变，分页器都要从第一页开始

#### 7.第七天

##### 1.详情页实现

​		静态页面，路由注册配置，携带params参数

​		路由跳转详情页，配置跳转瞬间页面的滚动行为 => 官方文档有配置方法

​		详情页动态展示：ajax请求函数，vuex管理，获取，展示数据

##### 2.展示图片列表以及放大镜的图片

​		解决报假错问题 => 当请求的数据还没回来，return 对象.属性就会出现undefined，报错

​		因此这里或一个{}空对象，保证不会出错

​		点击刷新页面，就等于项目重启，state中的数据必定重新初始化，重新发送请求

​		state里数据一开始是有的，只不过是我们初始化的，不是请求回来的

​		但是state这个初始化的数据，也会影响组件，组件也会获取这个数据

​		因为vue和vuex没办法永久存储数据，才有了localStorage（本地永久存储）和sessionStorage（关闭浏览器数据就没了）

##### 3.点击销售属性，切换选中状态 => 排他

##### 4.点击小图，切换每个小图的橙色边框，同时上面的zoom大图也做切换

​		点击小图，把小图的下标传给上面，上面更改下标，两张图就对应上了

##### 5.小图列表的轮播实现

​		Swiper

##### 6.放大镜的实现

​		vue中获取dom元素 => ref

​		鼠标动，蒙版动 想办法去让蒙版跟着动

​		即根据鼠标的位置求蒙版的位置

##### 7.商品购物数量的输入交互

​		v-model计数器

##### 8.添加购物车逻辑

​		之前我们的跳转几乎都是点击直接跳转，因为我们在跳转之前不需要发请求

​        比如从home去search 从search去详情，跳转时候不需要发请求，而是跳转过去后发请求拿数据

​		而加入购物车不一样，当我们点击添加购物车的时候，我们得需要先发请求给后台

​		后台需要把这个购物车信息存储数据库，请求成功之后，会返回给我们信息，我们根据这个信息再去跳转

​		否则，有可能后台添加数据库失败，而我们已经跳到下个页面，就出问题

​		1.先发请求添加购物车 api，但vuex中state不存数据，只用actions发请求（只是为了用vuex，学习熟练vuex）

​		2.根据请求添加购物车返回信息决定是否跳转到添加成功页面（P167）

​				通过dispatch的返回值来判断请求成功还是失败，返回值一定是个promise，用try catch判断成功失败

​		3.跳转添加购物车成功页面时，要带两个东西，商品数量和详情信息

​				商品数量通过路由传参query带过去

​				商品信息采用sessionStorage  `sessionStorage.setItem('SKUINFO_KEY',JSON.stringify(this.skuInfo))`

​						使用 JSON.stringify，不然存储进去的是一个 [object]

#### 8.第八天

##### 1.实现添加购物车页面动态展示，点击查看商品详情返回详情页

##### 2.购物车结算静态页面，路由配置

​		写api，三连环，但是请求获取到的是一个空数组，因为后台不知道哪个数据是谁发的，你要的是哪一条，所有返回空数组

##### 3.生成用户临时标识（随机字符串）

​		在user.js中的state中生成， getuserTempId()  =>  utils文件夹中定义，该函数专门用来生成临时标识（唯一的且不会轻易改变）

​		getuserTempId() ：

​		先从localStorage当中去获取用户的临时标识

​		localStorage获取不到数据返回的是null

​		如果获取到了，直接返回使用，如果没有获取到，再通过**uuid**（已安装好）重新创建，并且存储到localStorage

​		在ajax.js中导入临时标识，在请求拦截器中的请求头内部添加临时标识，后期每个请求都会带上这个临时标识

##### 4.购物车结算页面动态展示

​		统计购物车已选总数/总价：reduce

​		计算全选框数据：get() set()  =>  **every**  checkbox的**v-model**

##### 5.购物车结算页面的修改商品数量问题 

​		一旦失去焦点，立即给后台发请求，然后再修改 （！重点）

​		加减按钮最少减到1，再继续减会修正到1

##### 6.修改购物车结算页面选中状态

​		修改单个选中，同上，也要发请求

​		修改全部选中，使用**Promise.all**，采用单个修改的接口去修改多个，实际上应该有一个修改多个的接口

​		将单个的四个promise放到一个数组中，最后集体用Promise.all 

#### 9.第九天

##### 1.删除购物车单个信息

​		先发请求给后台，后台删掉数据库中的东西，返回信息，然后再重新发请求拿当前页面的数据

##### 2.删除购物车多个信息

​		和修改购物车信息一样，用Primise.all 用删除单个的接口去删除多个

##### 3.登陆注册页面

​		两个页面可以互相跳转

​		注册逻辑： 收集用户信息v-model，点击完成注册，发送请求给后台  点击验证码后台随机生成，向后台获取然后自动填写到表单

​		登陆逻辑：发请求返回一个token，获取token存储到localStorage中，登陆成功自动跳转首页

​							user的state中存储的是token，初始化为空串，自动登陆时才存储token的问题

​							user的mutation中直接修改用户的token

​							user的action中发请求，成功提交mutation修改用户的token

​							登陆成功的标志就是用户可以拿到token

##### 4.根据登陆token获取用户信息（token校验，也可以去判定token是不是过期）

​		**路由导航守卫**：

​         当路由跳转的时候，守卫可以拦住，检测是否有去往这个页面的条件

​         有特定条件才能到相应页面的功能

​         拦截路由，查看是否满足条件，满足的放行，不满足的处理

​		**全局导航守卫**：

​         无论是从哪个页面往哪个页面跳转，只要有路由跳转，就会拦住，进行检测

​         前置守卫： 配置的比较靠前 => 匹配路由前拦截

​         解析守卫： 配置的位置中间 => 匹配路由中拦截

​         后置守卫： 配置的比较靠后 => 匹配路由完成拦截，用的少

​        **路由独享守卫**：

​         只能去拦住固定的往某个页面跳转的，是配置再当前路由当中，时间比较靠前

​         前置守卫： 配置的比较靠前 => 匹配路由前拦截

​         解析守卫： 配置的位置中间 => 匹配路由中拦截

​         后置守卫： 配置的比较靠后 => 匹配路由完成拦截，用的少

​        **组件内守卫**：

​         只能去拦住固定的往某个页面跳转的，是配置在组件内部，也就是路由匹配已经完成了，时间比较靠后

​         只有一个，就是解析完了，已经跳转到组件的时候，但是组件还没创建成功的时候拦截

 //to 跳转的目的地路由对象

 //from 从哪来的路由对象

 //next 是一个函数

 // 根据参数不同，功能不同

 // next() 代表无条件放行

 // next('/') 代表强制跳转到指定的位置

 // next(false)代表什么都不做，原地不动

​		注册全局前置导航守卫，用来对token校验（根据token获取用户信息）：

​				在ajax中把登陆的token添加到请求头

![image-20210815205305472](C:\Users\Razer\AppData\Roaming\Typora\typora-user-images\image-20210815205305472.png)

![image-20210815205325472](C:\Users\Razer\AppData\Roaming\Typora\typora-user-images\image-20210815205325472.png)

​		获取到用户信息，在home页左上角展示

##### 5.用户的自动登陆  =>  页面刷新后，token还存在

​		自动登陆本质就是把用户的token存储下来，以后只要是重新登陆直接拿存储好的token就好了

​		保存token信息到localStorage中，且初始化的时候要先从localStorage中去拿

​		当token过期，要从localStorage中清空token信息

##### 6.实现用户的退出登录

​		写api请求接口函数  ？？？？？为什么退出也要发请求

​		请求成功在store中把用户信息和token的数据清除 => state和localStorage都要清除

userTempId 和 token的区别

​         userTempId 未登录状态下的用户身份识别标识

​         token 登陆状态下的用户身份识别标识

​         两个都存在，后台会合并临时id对应的信息到token对应的信息上，token是老大

#### 10.第十天

##### 1.订单交易页面动态展示，动态交互默认地址改变

​		修改默认地址： 排他，最终邮寄地址：computed中计算

##### 2.提交订单

​		此次不用vuex，直接用请求接口函数		

​		发请求给后台创建订单，后台返回订单编号，然后把订单编号携带跳转路由去到订单支付页面

##### 3.支付页面

​		支付页面收到订单编号，还需要发送一个请求获取支付信息，支付信息里包括了订单金额

​		**element-ui**的引入

​		安装，安装按需引入的babel相关的包

​         配置babel文件，引入并注册使用 => 点击立即支付弹出消息盒子

​		通过element-ui制作支付二维码弹出消息盒子

##### 4.支付流程

​		生成二维码：根据支付信息中的codeUrl生成二维码 => 用**node-qrcode** 用于把返回的图片地址生成二维码

​		展示完二维码立即开始**轮询**！ => 每隔2秒发一次请求，查询支付状态（定时器加判断，确保轮询只开一个）

​		根据返回的支付状态码去决定后续操作

​				如果查回来205表示还在支付中

​				如果查询回来是200 表示支付成功，清除定时器，自动跳转成功页面，关闭消息盒子

​         		同时保存状态码到data中，用来作为用户点击已成功支付按钮的判断依据

​		单独处理点击支付成功或问题按钮的逻辑

​				点击成功则根据支付状态码判断是否真的成功，如果不成功停留当前页面并提示，不关闭消息盒子

​        		点击遇到问题则发出提示并停止发送请求，关闭消息盒子 

​				支付成功页面可以选择继续购物，去到首页，也可以查看订单，去到用户中心

##### 5.我的订单页面，及二级路由组件的拆分和使用

​		我的订单和团购订单做二级路由 => 子路由组件拆分

#### 11.第十一天

##### 1.我的订单页面

​		获取动态数据，这次不用vuex，直接存到data中

​		单元格合并，实现分页器

##### 2.使用全局路由导航守卫解决未登录问题

​		如果时多个页面都要进行同一个检测，那么必然使用全局守卫（前置）

​		如果没登陆，访问相关页面将会跳转登陆页面，登陆后会自动跳转前面想去的页面

##### 3.只有未登录才能去到登陆页面

​		路由独享守卫可以实现，但是前面全局守卫已经实现过了

##### 4.跳转添加购物车成功页面

​		只有携带了skuNum（商品个数）和sessionStorage内部有skuInfo（商品详情）数据，才能看到成功页面

​		**路由独享守卫**

**5.界面跳转**（路由独享守卫）

​		只有从购物车界面才能跳到交易界面（创建订单）

​		只有从交易界面才能跳到支付界面

​		只有从支付界面才能跳转到支付成功界面

##### 6.图片懒加载 v-lazy

​		在还没有加载得到目标图片时，先显示loading图片

​		在<img>进入可视范围才加载请求目标图片

##### 7.路由懒加载

​		使用import from 这样的方式是同步执行，将所有的路由组件一次性打包在一个大的文件当中

​		这样打包之后，打包出来的文件体积比较大，当浏览器在访问这个文件加载的时候，效率不高

​		所以我们就想办法将所有的路由组件，分别打包为一个小的文件

​		浏览器在访问哪个组件的时候，再去加载哪一个小的文件，效率就会提升

​		这个过程就是我们所说的路由懒加载

​		import（）函数可以让文件单独打包，并且动态加载

##### 8.vee-validate验证注册部分

​		vee-validate是专门用来做表单验证的vue插件

​		安装引入并声明使用，在utils文件夹中另外配置

## 二、项目页面

#### App.vue 

##### header

##### router-view =>>  home

###### typeNav三级分类列表

###### ListContainer轮播和右侧列表

###### Recommend推荐

###### Rank热卖排行

###### Like猜你喜欢

###### Floor展示区

###### Brand品牌区

##### router-view =>>  search

###### typeNav三级分类列表

###### searchSelector品牌和属性选择区

###### pagination分页器

##### router-view =>>  detail

###### typeNav三级分类列表

###### Zoom放大镜效果

###### ImageList小图列表

##### router-view =>>  AddCartSuccess

##### router-view =>>  shopCart

登陆

注册

订单交易

支付

支付成功

##### footer

## 三、项目遇到的问题

1.不输入内容直接点击搜索按钮不会跳转到搜索页面的问题

​		路径会出问题，前面的/search没有了

​		参数没改变，所以报错， || undefined

2.分类列表防抖节流问题

3.主页搜索页来回切换，分类列表不断重复发送请求

4.跳转到搜索页面后，重新输入关键字或者点击类别不会再发送请求5.3
